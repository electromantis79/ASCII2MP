#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
**COMPLETION** = 90%  Sphinx Approved = **True**

.. topic:: Overview

    This module simulates a scoreboard.

    :Created Date: 3/16/2015
    :Modified Date: 10/24/2016
    :Author: **Craig Gunter**

"""

import threading, time
from sys import platform as _platform

from functions import *
from Console import Console
from Driver import LX_Driver
from Driver import ETN_Driver

from pyqt_subclasses import * #Holds PyQt4 imports
from UI_Scoreboard_Parts import *

class Scoreboard(Console):
	'''
	Simulation of a scoreboard with a built-in console.
	'''
	def __init__(self, modelName='LX1030', driverType='LXDriver', \
	serialInputFlag=0, parent=None, scene=None, vboseList=[1,0,0], boardColor='COMPANY_LOGO', \
	captionColor='WHITE', stripeColor='WHITE', checkEventsFlag=True, encodePacketFlag=True, serialInputType='MP'):

		if modelName=='modelList':
			self.model=modelName
			self.readDigitsPerModel()
		else:
			super(Scoreboard, self).__init__(vboseList=vboseList, checkEventsFlag=checkEventsFlag)
			verbose(['\nCreating Scoreboard object'], self.verbose)
			self.className='scoreboard'
			self.model=modelName
			self.driverType=driverType
			self.serialInputFlag=serialInputFlag
			self.graphicParent=parent
			self.graphicScene=scene
			self.boardColor=boardColor
			self.captionColor=captionColor
			self.stripeColor=stripeColor
			self.encodePacketFlag=encodePacketFlag
			self.serialInputType=serialInputType
			if self.serialInputType=='MP':
				self.serialOutputRefreshFrequency=.1
			elif self.serialInputType=='ASCII':
				self.serialOutputRefreshFrequency=.01

			self.simulatorRefreshFlag=False
			self.statWidth=12
			self.boardReset()
			self.serialString=''

	def boardReset(self):
		'''Reinitialize scoreboard.'''
		#Build dictionaries and components
		self.readDigitsPerModel()
		self.addressWordList=self.addressWordDict.keys()
		self.addressWordList.append(24)#colon
		self.addressWordList.append(5)#DOG
		#self.addressWordList.remove(18)
		verbose(['self.addressWordList', self.addressWordList], self.verboseMost)
		self.loadDrivers()
		for driver in self.driverList:
			if driver[:3]=='ETN':
					self.lxDict[driver].captionDict[self.game.guest]=self.game.teamsDict[self.game.guest].teamData['name']
					self.lxDict[driver].captionDict[self.game.home]=self.game.teamsDict[self.game.home].teamData['name']
					self.lxDict[driver].fontReceivedGuest=self.game.teamsDict[self.game.guest].teamData['font']
					self.lxDict[driver].fontReceivedHome=self.game.teamsDict[self.game.home].teamData['font']
					self.lxDict[driver].justifyReceivedGuest=self.game.teamsDict[self.game.guest].teamData['justify']
					self.lxDict[driver].justifyReceivedHome=self.game.teamsDict[self.game.home].teamData['justify']
		self.partsDict, self.positionDict, self.heightDict, self.boardWidth, self.boardHeight = readMasksPerModel(self.model)

		if self.serialInputFlag:
			if _platform == "linux" or _platform == "linux2":
				from MP_Serial import MP_Serial_Handler
				self.s = MP_Serial_Handler(serialInputType=serialInputType)
				from serial_packet_Class import Serial_Packet
				self.sp=Serial_Packet()
				self.align=True
				self.maxBytes=3
				self.overflow=self.maxBytes+10
				threading.Timer(0, self.serialInput).start()
				#threading.Timer(1, self.serialOutput).start()#Output is ross packet only

			elif _platform == "darwin":
				# OS X
				print 'Apple Sucks!!!!!'
			elif _platform == "win32":
				print '\nSerial Input not working for', _platform
				from serial_packet_Class import Serial_Packet
				self.sp=Serial_Packet()
				self.serialOutputRefreshFrequency=0
				threading.Timer(1, self.serialOutput).start()
				#self.encodePacket()

		self.addrMap.adjustAllBanks(self.game)
		self.data2Drivers(self.addrMap.wordList)

	#Init functions section

	def serialInput(self):
		'''Inputs serial packets.'''
		if self.serialInputType=='MP':
			self.s.serialInput(self.maxBytes, self.overflow)
			threading.Timer(.005, self.serialInput).start()
			for word in self.s.receiveList:
				group, bank, word, I_Bit, numericData = self.mp.Decode(word)
				addr=self.mp.GBW_to_MP_Address(group, bank, word)+1
				if addr==22 and self.align:
					self.align=False
					self.maxBytes=18
					self.overflow=self.maxBytes+1
					threading.Timer(.1, self.serialOutput).start()

			self.addrMap.UnMap(self.game, self.addressWordList, self.s.receiveList)
		elif self.serialInputType=='ASCII':
			self.s.serialInput()
			threading.Timer(.1, self.serialInput).start()

	def encodePacket(self):
		if self.encodePacketFlag:
			self.serialString=self.sp.encodePacket(self.game, printString=True)
		else:
			self.serialString=self.sp.loadOutputWords(self.game)

	def serialOutput(self):
		'''Outputs serial packets.'''
		if self.serialOutputRefreshFrequency:
			threading.Timer(self.serialOutputRefreshFrequency, self.serialOutput).start()
		self.encodePacket()
		try:
			self.s.serialOutput(self.serialString)
		except:
			pass

	def readDigitsPerModel(self):
		'''
		Read Spreadsheets/Digits_Per_Model.csv and build many dictionaries out of it.
		'''
		digitsPerModel='Spreadsheets/Digits_Per_Model.csv'
		csvReader=csv.DictReader(open(digitsPerModel, 'rb'), delimiter=',', quotechar="'")
		self.lxDict={}
		headerDict={}
		self.maskID_Dict={}
		self.addressWordDict={}
		modelDict={}
		self.functionDict={}
		self.driverPosDict={}
		self.powerSupplyDict={}
		self.driversPoweredByDict={}
		self.lxChassisDict={}
		self.lxDataOrderDict={}
		self.lxPerChassisDict={}
		self.chassisDict={}
		self.psChassisDict={}
		self.functionList=[]
		for count, row in enumerate(csvReader):
			try:
				model=row['model']
				if model=='':
					pass
				elif model!=self.model:
					#Doing this to make a list of all models on the spread sheet
					modelDict[model]=0
				else:
					modelDict[model]=0
					pcbValue=row['pcbValue']
					self.functionList.append(pcbValue)
					row['addressWord']=int(row['addressWord'])
					del row['model']
					del row['pcbValue']
					if row['']=='':
						del row['']#This requires spreadsheet to have a note in a column with no row 1 value
					self.functionDict[pcbValue]=row
			except ValueError:
				pass
		self.modelList=modelDict.keys()
		for function in self.functionList:
			self.driverPosDict[self.functionDict[function]['LXDriver']]=self.functionDict[function]['lxPosition']
			headerDict[self.functionDict[function]['LXHeader']]=0
			self.maskID_Dict[self.functionDict[function]['mask_ID']]=self.functionDict[function]['maskType']
			self.addressWordDict[self.functionDict[function]['addressWord']]=0
			self.powerSupplyDict[self.functionDict[function]['psChassis']]=(self.functionDict[function]['psPosition'], self.functionDict[function]['psLabel'])
			if self.functionDict[function]['LXDriver'][:3]=='ETN':
				if self.game.gameData['sportType']=='basketball' or self.game.gameData['sportType']=='hockey':
					self.driversPoweredByDict[self.functionDict[function]['LXDriver']]=1
				else:
					self.driversPoweredByDict[self.functionDict[function]['LXDriver']]=self.functionDict[function]['lxPosition']
			else:
				self.driversPoweredByDict[self.functionDict[function]['LXDriver']]=self.functionDict[function]['psChassis']
			self.lxChassisDict[self.functionDict[function]['LXDriver']]=self.functionDict[function]['chassisMask']
			self.lxDataOrderDict[self.functionDict[function]['LXDriver']]=self.functionDict[function]['dataOrder']
			self.psChassisDict[self.functionDict[function]['psChassis']]=self.functionDict[function]['chassisMask']
			self.chassisDict[self.functionDict[function]['chassisMask']]=0

		self.chassisList=self.chassisDict.keys()
		self.driverList=self.driverPosDict.keys()
		self.headerList=headerDict.keys()
		self.maskID_List=self.maskID_Dict.keys()
		self.powerSupplyList=self.powerSupplyDict.keys()

		for supply in self.powerSupplyList:
			self.powerSupplyDict[supply]=([], self.powerSupplyDict[supply])
			for driver in self.driverList:
				if self.driversPoweredByDict[driver]==supply:
					self.powerSupplyDict[supply][0].append(driver)
				elif \
				(self.game.gameData['sportType']=='basketball' or \
				self.game.gameData['sportType']=='hockey') and driver[:3]=='ETN':
					self.powerSupplyDict[supply][0].append(driver)
		for chassis in self.chassisList:
			self.lxPerChassisDict[chassis]=[]
			for driver in self.driverList:
				if self.lxChassisDict[driver]==chassis:
					self.lxPerChassisDict[chassis].append(driver)

	def loadDrivers(self):
		'''Creates a dictionary of all driver objects in the scoreboard.'''
		if self.driverType=='LXDriver':
			for driver in self.driverList:
				verbose(['loading driver', driver], self.verboseMore)
				if driver[:3]=='ETN':
					self.lxDict[driver]=ETN_Driver(driver, extraJumpers=[])
				else:
					self.lxDict[driver]=LX_Driver(driver, extraJumpers=[])


	#End init functions

	#Callable functions section

	def data2Drivers(self, sendList):
		'''
		Main function used to communicate to drivers.
		'''
		#Send data to each driver
		for driver in self.driverList:
			verbose(['sending data to driver', driver], self.verboseMore)
			self.lxDict[driver].receive(sendList)

	def _printLXHeaders(self):
		threading.Timer(.1, self._printLXHeaders).start()
		for lx in self.lxDict:
			print lx, self.lxDict[lx].J5, self.lxDict[lx].J4
			print lx, self.lxDict[lx].J9, self.lxDict[lx].J6
			print lx, self.lxDict[lx].J8
			print lx, self.lxDict[lx].J10
			print

def test():
	'''Test function if module ran independently.'''
	print "ON"
	sport='MPFOOTBALL1'
	c=Config()
	configDict=readConfig()
	c.writeSport(sport)
	c.writeSERVER(True)
	model= Scoreboard(modelName='LX3880', driverType='LXDriver', serialInputFlag=1)
	print model.game.clockDict['periodClock'].countUp
	printDictsExpanded(model,1)
	#sport='MPMULTISPORT1-football'
	#c.writeSport(sport)
	#model.Reset()
	#model.boardReset()
	#printDict(model.__dict__,1)
	#keyPressed='F8'
	#model.keyPressed(keyPressed)
	#time.sleep(2)
	#model.updateMPData()
	#mp=MP_Data_Handler()
	#LHword0 = mp.Encode(2, 3, 2, 1, 0, 6,9, 0, 0)
	#LHword1 = mp.Encode(2, 1, 2, 1, 0, 3,4, 0, 0)
	#sendList=[LHword0, LHword1]
	#model._printLXHeaders()
	'''
	import Network, logging
	jobs=[]
	server=multiprocessing.Process(name='server', target=Network.chat_server)
	jobs.append(server)
	multiprocessing.log_to_stderr(logging.DEBUG)
	server.start()
	server.join()
	while 1:
		#
		if not server.is_alive() and configDict['SERVER']==True:
			print server.exitcode
			configDict['SERVER']=False
			c.writeSERVER(False)
			server.terminate()
		elif configDict['SERVER']==False:
			time.sleep(3)
			server=multiprocessing.Process(name='server', target=Network.chat_server)
			jobs.append(server)
			server.start()
			server.join()
	'''

if __name__ == '__main__':
	from Config import Config
	from MP_Data_Handler import MP_Data_Handler
	import multiprocessing
	test()
