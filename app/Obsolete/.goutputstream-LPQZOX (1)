#!/usr/bin/env python

# by Craig Gunter
#
# "Address_Mapping module"
#
# Address_Mapping()Input = None
#
# 		Map() = Maps key to event
#
#
#			main() =


#	Varibles available /w Defaults
"""




"""

from time import sleep
import sys

from Config import *
from Game import *
from MP_Data_Handler import *
from Driver import *

class Address_Mapping(object):

	def __init__(self, sportType='Generic'):
		self.sportType=sportType

		self.verbose=False
		self.mp = MP_Data_Handler()

		self.seq = range(1,33)
		self.wordsDict = dict.fromkeys(self.seq, 0)
		self.blankMap()

		self.lastWordsDict = {}

		from Game import readConfig
		self.configDict=readConfig()
		self.sport=self.configDict['sport']

		self.addressMapDict={}
		self.fullAddressMapDict = self.readAddressMap()
		self.buildAddrMap(self.sport)

	#startup methods
	def blankMap(self):
		#Build blank MP wordsDict
		for i in range(2):
			for j in range(4):
				self.wordsDict[(i*4+j)*4+1] = self.mp.Encode(i+1, j+1, 1, 0, 0, 0x0, 0x0, 'AlwaysHighLow', 0)
				self.wordsDict[(i*4+j)*4+2] = self.mp.Encode(i+1, j+1, 2, 0, 0, 0x0, 0x0, 'AlwaysHighLow', 0)
				self.wordsDict[(i*4+j)*4+3] = self.mp.Encode(i+1, j+1, 3, 0, 0, 0, 0, 'AlwaysHighLow', 0)
				self.wordsDict[(i*4+j)*4+4] = self.mp.Encode(i+1, j+1, 4, 1, 0, 0, 0, 'AlwaysHighLow', 0)

	def buildAddrMap(self, sport):
		for address in self.seq:
			try:
				self.addressMapDict[address]=self.fullAddressMapDict[address][1]
			except:
				print 'Error', address, self.addressMapDict[address]['HIGH_NIBBLE'], self.addressMapDict[address]['LOW_NIBBLE']

	def readAddressMap(self):
		AddressMap='Spreadsheets/AddressMap.csv'
		csvReader=csv.DictReader(open(AddressMap, 'rb'), delimiter=',', quotechar="'")
		address={}
		AltDict = {}
		seq = range(1,33)
		dictionary = dict.fromkeys(seq, 0)
		for row in csvReader:
			try:
				sport=row['SPORT']
				sportType=row['SPORT_TYPE']
				if sport==self.sport and sportType==self.sportType:
					addressWord=int(row['ADDRESS_WORD_NUMBER'])
					ALT=int(row['ALT'])
					#print '\nsport', sport,'\nsportType', sportType,'\naddressWord', addressWord,'\nALT', ALT
					del row['SPORT']
					del row['SPORT_TYPE']
					del row['ADDRESS_WORD_NUMBER']
					del row['ALT']

					if dictionary[addressWord]==0:
						AltDict.clear()
						AltDict[ALT]=row
						copyDict=AltDict.copy()
						dictionary[addressWord]=copyDict
					elif dictionary[addressWord].has_key(ALT):
						AltDict.clear()
						AltDict[ALT]=row
						copyDict=AltDict.copy()
						dictionary[addressWord]=copyDict
					else:
						AltDict[ALT]=row
						copyDict=AltDict.copy()
						dictionary[addressWord]=copyDict


					#print '\nAltDict\n', AltDict, '\ndictionary\n', dictionary[addressWord]
					#AltDict.clear()
					#raw_input()
				else:
					#raw_input()
					pass

			except ValueError:
				print '\npass\n'
				raw_input()
				pass
		#print self.sport, self.sportType, dictionary
		return dictionary
	#adjustAllBanks chain is called here to change words from blank to sport defaults
	#startup methods end

	#ONLY callable method for this class!!!!!!!!!!!!!!!!!
	def Map(self, game):

		#Updates the list of MP Format data packs to be sent

		self.adjustAllBanks(game)
		#	"The adjustAllBanks chain"
		#adjustAllBanks calls _updateAddrWords
		#_updateAddrWords calls _loadFromAddDict
		#_loadFromAddDict calls mp.Encode
		#		Current Dict of 32 words are up to date
		#adjustAllBanks calls updateSendList
		#		only load values that have changed in to the send list
		return

	#G1		B1=1,2,3,4		B2=5,6,7,8 		B3=9,10,11,12, 		B4=13,14,15,16
	#G2		B1=17,18,19,20 	B2=21,22,23,24 	B3=25,26,27,28 		B4=29,30,31,32

	#Map()'s main methods - "The adjustAllBanks chain"
	def adjustAllBanks(self, game):
		#print '\n-------adjustAllBanks-------\n'
		Alts = []
		underMinute = game.getClockData('periodClock', 'currentTime')<60 and game.gameSettings['periodClockTenthsFlag']

		if game.sport=='MPBASEBALL1' or game.sport=='MMBASEBALL3':
			if game.getClockData('periodClock', 'currentTime')<60:
				if game.gameSettings['2D_Clock']:
					Alts=self.formatALTS(Alts, [2,21], 2)
			else:
				if game.gameSettings['2D_Clock']:
					Alts=self.formatALTS(Alts, [1,2,21,22], 2)
			if game.gameSettings['hoursFlagJumper']:
				Alts=self.formatALTS(Alts, [3,23], 2)
			if game.gameSettings['scoreTo19Flag']:
				Alts=self.formatALTS(Alts, [5,6,7,8,9,10,11,12,25,26,27,28], 2)
			if game.gameSettings['timeOfDayClockEnable']:
				Alts=self.formatALTS(Alts, [1,2,21,22], 4)

		elif game.sport=='MPLINESCORE5':
			if game.gameSettings['clock_3D_or_less_Flag']:
				Alts=self.formatALTS(Alts, [23], 2)
			if game.gameSettings['doublePitchCountFlag'] and game.gameSettings['pitchSpeedFlag']:
				Alts=self.formatALTS(Alts, [5,14,15,16,31,32], 2)
			elif game.gameSettings['doublePitchCountFlag']:
				Alts=self.formatALTS(Alts, [14,15,16,31,32], 2)
			elif game.gameSettings['pitchSpeedFlag']:
				Alts=self.formatALTS(Alts, [31,32], 3)
				Alts=self.formatALTS(Alts, [5], 2)
			if game.gameSettings['timeOfDayClockEnable']:
				Alts=self.formatALTS(Alts, [21,22], 4)
			elif underMinute:
				Alts=self.formatALTS(Alts, [21,22], 2)

		elif game.sport=='MPLINESCORE4':
			if underMinute:
				Alts=self.formatALTS(Alts, [21,22], 2)
			if game.gameSettings['timeOfDayClockEnable']:
				Alts=self.formatALTS(Alts, [21,22], 4)

		elif game.sport=='MPMP_15X1' or game.sport=='MPMP_14X1' or game.sport=='MMBASEBALL4':
			pass

		elif self.sport=='MPMULTISPORT1-football' or self.sport=='MPMULTISPORT1-baseball' or \
		self.sport=='MPLX3450-football' or self.sport=='MPLX3450-baseball':
			if self.sport=='MPLX3450-baseball' and game.getClockData('periodClock', 'currentTime')<60:
				Alts=self.formatALTS(Alts, [1], 2)
			if underMinute:
				Alts=self.formatALTS(Alts, [6,7,8,21,22], 2)
			if game.gameSettings['clock_3D_or_less_Flag']:
				Alts=self.formatALTS(Alts, [31], 2)
			if self.sport=='MPMULTISPORT1-football':
				if game.gameSettings['timeOutTimerEnable'] and game.gameSettings['timeOutTimerToScoreboard']:
					Alts=self.formatALTS(Alts, [6,7,8,21,22], 3)

			elif self.sport=='MPLX3450-football':
				if game.gameSettings['timeOutTimerEnable'] and game.gameSettings['timeOutTimerToScoreboard']:
					Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 3)
				if game.gameSettings['timeOfDayClockEnable']:
					Alts=self.formatALTS(Alts, [1,2], 4)

			if game.gameSettings['timeOfDayClockEnable']:
				Alts=self.formatALTS(Alts, [6,7,8,21,22], 4)

		elif game.sport=='MPFOOTBALL1':
			if game.gameSettings['timeOfDayClockEnable']:
				Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 4)
			elif game.gameSettings['timeOutTimerEnable'] and game.gameSettings['timeOutTimerToScoreboard']:
				Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 3)
			elif game.getClockData('periodClock', 'currentTime')<60:
				if not game.gameSettings['trackClockEnable'] and game.gameSettings['periodClockTenthsFlag']:
					Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 2)

			if game.gameSettings['trackClockEnable']: # Just Tenths Units word 3 or 4
				if game.gameSettings['periodClockTenthsFlag']:
					Alts=self.formatALTS(Alts, [11,18], 2)

		elif game.sport=='MMFOOTBALL4':
			if underMinute:
				Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 2)
			if game.gameSettings['yardsToGoUnits_to_quarter']:
				Alts=self.formatALTS(Alts, [3,23], 2)

		elif game.sport=='MPBASKETBALL1':
			if game.gameSettings['timeOfDayClockEnable']:
				Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 4)
			elif game.gameSettings['timeOutTimerEnable'] and game.gameSettings['timeOutTimerToScoreboard']:
				Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 3)
			elif underMinute:
				Alts=self.formatALTS(Alts, [1,2,6,7,8,21,22], 2)

		self._updateAddrWords(game, Alts)

		self.updateSendList()

	def formatALTS(self, List, addresses, ALT):
		for address in addresses:
			List.append((address, ALT))
		return List

	def _updateAddrWords(self, game, Alts):
		#print Alts
		#print self.addressMapDict
		self.buildAddrMap(self.sport)
		if game.gameSettings['timeOfDayClockBlankingEnable']:
			self.addressMapDict.clear()
			self.blankMap()
			for index, addressTup in enumerate(Alts):
				if addressTup[1]!=4:
					print Alts
					Alts.remove(index)
		for addressTup in Alts:
			#print addressTup
			self.addressMapDict[addressTup[0]]=self.fullAddressMapDict[addressTup[0]][addressTup[1]]
		#print self.addressMapDict

		for address in self.seq:
			try:
				group, bank, word, iBit, hBit, highNibble, lowNibble, blankType, segmentData = self._loadFromAddDict(game, address)
				self.wordsDict[address]=self.mp.Encode(group, bank, word, iBit, hBit, highNibble, lowNibble, blankType, segmentData)
			except:
				pass
				print 'ERROR'

	def _loadFromAddDict(self, game, address): #This is the beginning of data manipulation into the MP Format!!!
		''' Get word info and prepare it for encoding '''
		group= int(self.addressMapDict[address]['GROUP']) #INT
		word= int(self.addressMapDict[address]['WORD']) #INT
		bank= int(self.addressMapDict[address]['BANK']) #INT
		iBit=self.addressMapDict[address]['I_BIT']
		hBit=self.addressMapDict[address]['H_BIT']
		highNibble=self.addressMapDict[address]['HIGH_NIBBLE']
		lowNibble=self.addressMapDict[address]['LOW_NIBBLE']
		blankType=self.addressMapDict[address]['BLANK_TYPE']
		segmentData=self.addressMapDict[address]['SEGMENT_DATA']

		iBit = self.iBit_Format(game, iBit)#string to int
		hBit = self.hBit_Format(game, hBit)#string to int
		highNibble, lowNibble, blankType = self.Nibble_Format(game, highNibble, lowNibble, blankType, word, address)
		segmentData = self.segmentData_Format(game, segmentData)#string to int

		return group, bank, word, iBit, hBit, highNibble, lowNibble, blankType, segmentData

	def updateSendList(self):
		self.sendListAddr = []
		self.sendList = []
		for address in self.wordsDict:
			self.sendListAddr.append(address)
			self.sendList.append(self.wordsDict[address])
		if self.verbose:
			print 'sendListAddr = ', self.sendListAddr,
			print
	#Map()'s main methods end

	#Formatting Functions
	def iBit_Format(self, game, iBit):
		#Format data - iBit
		team=self.teamExtract(game, iBit)
		if iBit=='0'or iBit=='':
			iBit=0
		elif iBit=='1' or iBit=='active':
			iBit=1
		elif iBit=='teamOneBonus2' or iBit=='teamTwoBonus2':
			value=game.getTeamData(team, 'bonus')
			if value==2:
				iBit=1
			else:
				iBit=0
		elif iBit[:7]=='teamTwo' or iBit[:7]=='teamOne':
			iBit=iBit[:7]+str.lower(iBit[7])+iBit[8:]
			iBit=game.getTeamData(team, iBit[7:])
		elif iBit=='outs1':
			outs=game.getGameData('outs')
			if outs>=1:
				iBit=1
			else:
				iBit=0
		elif iBit=='outs2':
			outs=game.getGameData('outs')
			if outs>=2:
				iBit=1
			else:
				iBit=0
		elif iBit=='quarter4':
			quarter=game.getGameData('quarter')
			if quarter>=4:
				iBit=1
			else:
				iBit=0
		else:
			iBit=game.getGameData(iBit)
		return iBit

	def hBit_Format(self, game, hBit):
		#Format data - hBit
		team=self.teamExtract(game, hBit)
		if hBit=='0'or hBit=='':
			hBit=0
		elif hBit=='1':
			hBit=1
		elif hBit[:7]=='teamTwo' or hBit[:7]=='teamOne':
			hBit=hBit[:7]+str.lower(hBit[7])+hBit[8:]
			hBit=game.getTeamData(team, hBit[7:])
		else:
			hBit=game.getGameData(hBit)
		return hBit

	def teamExtract(self, game, value):
		team=None
		if value[:7]=='teamOne':
			team=game.guest
		elif value[:7]=='teamTwo':
			team=game.home
		return team

	def trimTeamName(self, name):
		name=name[:7]+str.lower(name[7])+name[8:]
		name=name[7:]
		return name

	def periodClockValueCheck(self, value):
		answer = value=='hoursUnits' or value=='tenthsUnits' or value=='minutesUnits' \
			or value=='minutesTens'or value=='secondsUnits'or value=='secondsTens'
		return answer

	def teamValueCheck(self, value):
		return value[:4]=='team'

	def gameValueCheck(self, value):
		if self.periodClockValueCheck(value):
			return 0
		elif self.teamValueCheck(value):
			return 0
		return 1

	def Nibble_Format(self, game, highNibble, lowNibble, blankType, word, addrWordNumber):
		if self.verbose:
			print '\nNibble Format highNibble, lowNibble, blankType, word, addrWordNumber -- \n', highNibble, lowNibble, blankType, word, addrWordNumber
		#handle nibble blanking and rejected values
		if highNibble=='blank'and lowNibble=='blank':
			highNibble=lowNibble=0
			blankType='AlwaysHighLow'
		elif highNibble=='blank':
			highNibble=0
			blankType='AlwaysHigh'
		elif lowNibble=='blank':
			lowNibble=0
			blankType='AlwaysLow'

		if highNibble=='' or highNibble=='0':
			highNibble=0
		if lowNibble=='' or lowNibble=='0':
			lowNibble=0

		#high nibble
		blankTypeH=False
		blankTypeH25=False
		if highNibble!=0:
			teamString=highNibble[:7]
			teamH=self.teamExtract(game, highNibble)
			if self.periodClockValueCheck(highNibble):
				if game.gameSettings['hoursFlag'] and (highNibble=='minutesTens' or highNibble=='secondsTens'):
					blankType=0
				highNibble=game.getClockData('periodClock', highNibble)
			elif highNibble=='delayOfGameClock_secondsTens':
				highNibble=game.getClockData('delayOfGameClock', highNibble[17:])
			elif highNibble=='shotClock_secondsTens':
				highNibble=game.getClockData('shotClock', highNibble[10:])
			elif highNibble=='timeOutTimer_secondsTens' or highNibble=='timeOutTimer_minutesTens':
				highNibble=game.getClockData('timeOutTimer', highNibble[13:])
			elif highNibble=='segmentTimer_secondsTens' or highNibble=='segmentTimer_minutesTens':
				highNibble=game.getClockData('segmentTimer', highNibble[13:])
			elif highNibble=='timeOfDayClock_hoursTens' or highNibble=='timeOfDayClock_minutesTens':
				highNibble=game.getClockData('timeOfDayClock', highNibble[15:])
			elif self.teamValueCheck(highNibble):
				highNibble=self.trimTeamName(highNibble)
				highNibble=game.getTeamData(teamH, highNibble)
				if highNibble==255 or highNibble==25:
					blankTypeH=True
					if highNibble==25:
						blankTypeH25=True
					highNibble=0
			else:
				HOLDhighNibble=highNibble
				highNibble=game.getGameData(highNibble)
				if highNibble==255 or highNibble==25:
					blankTypeH=True
					if highNibble==25:
						blankTypeH25=True
					highNibble=0
				elif HOLDhighNibble and highNibble==0 and game.gameSettings['playerMatchGameFlag']:
					blankType=0

		#low nibble
		blankTypeL=False
		if lowNibble!=0:
			teamL=self.teamExtract(game, lowNibble)
			if self.periodClockValueCheck(lowNibble):
				lowNibble=game.getClockData('periodClock', lowNibble)
			elif lowNibble=='delayOfGameClock_secondsUnits':
				lowNibble=game.getClockData('delayOfGameClock', lowNibble[17:])
			elif lowNibble=='shotClock_secondsUnits':
				lowNibble=game.getClockData('shotClock', lowNibble[10:])
			elif lowNibble=='timeOutTimer_secondsUnits' or lowNibble=='timeOutTimer_minutesUnits' or lowNibble=='timeOutTimer_minutesTens':
				lowNibble=game.getClockData('timeOutTimer', lowNibble[13:])
			elif lowNibble=='segmentTimer_secondsUnits' or lowNibble=='segmentTimer_minutesUnits' or lowNibble=='segmentTimer_minutesTens':
				lowNibble=game.getClockData('segmentTimer', lowNibble[13:])
			elif lowNibble=='timeOfDayClock_hoursUnits' or lowNibble=='timeOfDayClock_minutesUnits' or lowNibble=='timeOfDayClock_hoursTens':
				lowNibble=game.getClockData('timeOfDayClock', lowNibble[15:])
			elif self.teamValueCheck(lowNibble):
				lowNibble=self.trimTeamName(lowNibble)
				lowNibble=game.getTeamData(teamL, lowNibble)
				if lowNibble==255 or blankTypeH25:
					blankTypeL=True
					lowNibble=0
			else:
				lowNibble=game.getGameData(lowNibble)
				if lowNibble==255 or blankTypeH25:
					blankTypeL=True
					lowNibble=0

		#linescore blanking dependent on 255 value
		if blankTypeH and blankTypeL:
			blankType='IsolateHL'
		elif blankTypeH:
			blankType='AlwaysHigh'
		elif blankTypeL:
			if word==1 or word ==2:
				blankType='AlwaysLow'
			elif word==3 or word==4:
				blankType='IsolateHL'

		if highNibble>15 or lowNibble>15:
			print '\nNibble Format highNibble, lowNibble, blankType, word, addrWordNumber -- \n', highNibble, lowNibble, blankType, word, addrWordNumber
		return highNibble, lowNibble, blankType

	def segmentData_Format(self, game, segmentData):
		#Format data - segmentData
		#print 'segmentData before:', segmentData
		if segmentData=='' or segmentData=='0':
			segmentData=0
		elif segmentData=='BSO':
			segmentData=self._BSODecode(game)
		elif segmentData=='Down_Quarter':
			segmentData=self._DownQuarterDecode(game)
		elif segmentData=='fQtr4_gDec':
			segmentData=''
			if game.getGameData('decimalIndicator'):
				segmentData='g'
			if game.getGameData('quarter')>=4:
				segmentData+='f'
		elif segmentData=='gDec':
			if game.getGameData('decimalIndicator'):
				segmentData='g'
			else:
				segmentData=''
		elif segmentData=='f_hitIndicator':
			if game.getGameData('hitIndicator'):
				segmentData='f'
			else:
				segmentData=''
		elif segmentData=='abcBall_efStrike':
			segmentData=''
			balls=game.getGameData('balls')
			strikes=game.getGameData('strikes')
			if balls==0:
				pass
			elif balls==1:
				segmentData='a'
			elif balls==2:
				segmentData='ab'
			elif balls>=3:
				segmentData='abc'
			if strikes==0:
				pass
			elif strikes==1:
				segmentData+='e'
			elif strikes>=2:
				segmentData+='ef'
		elif segmentData=='bc_strike':
			segmentData=''
			strikes=game.getGameData('strikes')
			if strikes==0:
				pass
			elif strikes==1:
				segmentData+='b'
			elif strikes>=2:
				segmentData+='bc'
		elif segmentData=='abcBall_deOut_gDec':
			segmentData=''
			balls=game.getGameData('balls')
			outs=game.getGameData('outs')
			if balls==0:
				pass
			elif balls==1:
				segmentData='a'
			elif balls==2:
				segmentData='ab'
			elif balls>=3:
				segmentData='abc'
			if outs==0:
				pass
			elif outs==1:
				segmentData+='d'
			elif outs>=2:
				segmentData+='de'
			if game.getGameData('decimalIndicator'):
				segmentData+='g'
		elif segmentData=='aGeHposs_fQrt4_gDec':
			segmentData=''
			if game.getTeamData(game.guest, 'possession'):
				segmentData='a'
			if game.getTeamData(game.home, 'possession'):
				segmentData+='e'
			if game.getGameData('decimalIndicator'):
				segmentData+='g'
			if game.getGameData('quarter')>=4:
				segmentData+='f'
		elif segmentData=='abcde_PossBonus':
			segmentData=''
			if game.getTeamData(game.home, 'possession'):
				segmentData='a'
			if game.getTeamData(game.guest, 'possession'):
				segmentData+='b'
			homeB=game.getTeamData(game.home, 'bonus')
			guestB=game.getTeamData(game.guest, 'bonus')
			if homeB==0:
				pass
			if homeB==1:
				segmentData+='c'
			if homeB>=2:
				segmentData+='ce'
			if guestB==0:
				pass
			if guestB>=1:
				segmentData+='d'
		elif segmentData=='home_ace_PossBonus':
			segmentData=''
			if game.getTeamData(game.home, 'possession'):
				segmentData='a'
			homeB=game.getTeamData(game.home, 'bonus')
			if homeB==0:
				pass
			if homeB==1:
				segmentData+='c'
			if homeB>=2:
				segmentData+='ce'
		elif segmentData=='guest_ace_PossBonus':
			segmentData=''
			if game.getTeamData(game.guest, 'possession'):
				segmentData='a'
			guestB=game.getTeamData(game.guest, 'bonus')
			if guestB==0:
				pass
			if guestB==1:
				segmentData+='c'
			if guestB>=2:
				segmentData+='ce'
		#print 'segmentData after:', segmentData
		return segmentData

	#Segment Decode Functions
	def _BSODecode(self, game):
		segmentData=''
		balls=game.getGameData('balls')
		strikes=game.getGameData('strikes')
		outs=game.getGameData('outs')
		if balls==0:
			pass
		elif balls==1:
			segmentData='a'
		elif balls==2:
			segmentData='ab'
		elif balls>=3:
			segmentData='abc'
		if strikes==0:
			pass
		elif strikes==1:
			segmentData+='d'
		elif strikes>=2:
			segmentData+='de'
		if outs==0:
			pass
		elif outs==1:
			segmentData+='f'
		elif outs>=2:
			segmentData+='fg'
		return segmentData

	def _DownQuarterDecode(self, game):
		segmentData=''
		down=game.getGameData('down')
		quarter=game.getGameData('quarter')
		if down==0:
			pass
		elif down==1:
			segmentData='a'
		elif down==2:
			segmentData='ab'
		elif down==3:
			segmentData='abc'
		elif down>=4:
			segmentData='abcd'
		if quarter==0:
			pass
		elif quarter==1:
			segmentData+='e'
		elif quarter==2:
			segmentData+='ef'
		elif quarter==3:
			segmentData+='efg'
		elif quarter>=4:
			segmentData+='efg'
		return segmentData
	#Segment Decode Functions End
	#Formatting Functions End

	#MP Data decoded and stored in Game Section
	###
	def UnMap(self, game, addressWordList=[], sendList=[]):
		for word in sendList:
			group, bank, word, I_Bit, numericData = self.mp.Decode(word)
			addr=self.mp.GBW_to_MP_Address(group, bank, word)+1
			decodeData=(addr, group, bank, word, I_Bit, numericData)
			#print 'addr:', addr, group, bank, word, 'I:', I_Bit, 'Data:', numericData

			if addr in addressWordList and not self.tunnelCheck(word, numericData):
				#print 'enter list and tunnel check'
				if (addr==21 or addr==22):
					if not game.gameData['colonIndicator']:
						dataNames=self.getDictInfo(addr, ALT=True)
						self.saveData(game, decodeData, dataNames)
					else:
						dataNames=self.getDictInfo(addr)
						self.saveData(game, decodeData, dataNames)
				elif addr==24:
					dataNames=self.getDictInfo(addr)
					self.saveData(game, decodeData, dataNames)
					game.colonOld=game.gameData['colonIndicator']
				else:
					dataNames=self.getDictInfo(addr)
					self.saveData(game, decodeData, dataNames)
			else:
				pass#print 'addr', addr, 'skipped'#
		return game

	def saveData(self, game, decodeData, dataNames):
		addr, group, bank, word, I_Bit, numericData = decodeData
		iBit, hBit, highNibble, lowNibble, segmentData = dataNames
		#print '\naddr', addr, 'iBit', iBit, 'hBit', hBit
		#print 'highNibble', highNibble, 'lowNibble', lowNibble, 'segmentData', segmentData
		if word==3 or word==4:
			if segmentData=='':
				highData=0
				lowData=numericData&0x7f
				lowData=self.mp.numericDataDecode(lowData)
				H_Bit=numericData&0x80
				hTeam=self.teamExtract(game, hBit)
				self.setData(game, hBit, H_Bit, hTeam)
				iTeam=self.teamExtract(game, iBit)
				self.setData(game, iBit, I_Bit, iTeam)
				lowTeam=self.teamExtract(game, lowNibble)
				self.setData(game, lowNibble, lowData, lowTeam)
				highTeam=self.teamExtract(game, highNibble)
				self.setData(game, highNibble, highData, highTeam)
				#print '\naddr', addr, 'iTeam', iTeam, I_Bit, 'hTeam', hTeam, H_Bit
				#print 'highTeam', highTeam, highData, 'lowTeam', lowTeam, lowData
			else:
				#decode segment datas storage value
				H_Bit=(numericData&0x80)>>7
				hTeam=self.teamExtract(game, hBit)
				self.setData(game, hBit, H_Bit, hTeam)
		else:
			highData=(numericData&0xf0)>>4
			lowData=numericData&0x0f
			iTeam=self.teamExtract(game, iBit)
			self.setData(game, iBit, I_Bit, iTeam)
			lowTeam=self.teamExtract(game, lowNibble)
			highTeam=self.teamExtract(game, highNibble)
			#print '\naddr', addr, 'iTeam', iTeam, I_Bit
			#print 'highTeam', highTeam, highData, 'lowTeam', lowTeam, lowData
			self.setData(game, highNibble, highData, highTeam)
			self.setData(game, lowNibble, lowData, lowTeam)

	def setData(self, game, name, value, team=None):
		if self.gameValueCheck(name):
			#print 'GAME'
			game.setGameData(name, value, places=1)
		elif self.teamValueCheck(name):
			#print 'TEAM'
			name=self.trimTeamName(name)
			game.setTeamData(team, name, value, places=1)
		elif self.periodClockValueCheck(name):
			#print 'CLOCK'
			game.setGameData('periodClock_'+name, value, places=1)
		else:
			print 'FAIL'
		return game

	def tunnelCheck(self, word, numericData):
		highData=(numericData&0xf0)>>4
		lowData=numericData&0x0f
		if word==1:
			if (lowData>=0xa and lowData!=0xf) or (highData>=0xa and highData!=0xf):
				return 1
		return 0

	def getDictInfo(self, addr, ALT=False):
		if ALT:
			iBit=self.fullAddressMapDict[addr][2]['I_BIT']
			hBit=self.fullAddressMapDict[addr][2]['H_BIT']
			lowNibble=self.fullAddressMapDict[addr][2]['LOW_NIBBLE']
			highNibble=self.fullAddressMapDict[addr][2]['HIGH_NIBBLE']
			segmentData=self.fullAddressMapDict[addr][2]['SEGMENT_DATA']
		else:
			iBit=self.fullAddressMapDict[addr][1]['I_BIT']
			hBit=self.fullAddressMapDict[addr][1]['H_BIT']
			lowNibble=self.fullAddressMapDict[addr][1]['LOW_NIBBLE']
			highNibble=self.fullAddressMapDict[addr][1]['HIGH_NIBBLE']
			segmentData=self.fullAddressMapDict[addr][1]['SEGMENT_DATA']
		dataNames=(iBit, hBit, highNibble, lowNibble, segmentData)
		return dataNames


class Lamptest_Mapping(Address_Mapping):
	def __init__(self):
		super(Lamptest_Mapping, self).__init__()

		for i in range(2):
			for j in range(4):
				self.wordsDict[(i*4+j)*4+1] = self.mp.Encode(i+1, j+1, 1, 1, 1, 8, 8, 0, 0)# 0x58 is 88 in decimal for lamp test
				self.wordsDict[(i*4+j)*4+2] = self.mp.Encode(i+1, j+1, 2, 1, 1, 8, 8, 0, 0)
				self.wordsDict[(i*4+j)*4+3] = self.mp.Encode(i+1, j+1, 3, 1, 1, 0, 8, 0, 0)
				self.wordsDict[(i*4+j)*4+4] = self.mp.Encode(i+1, j+1, 4, 1, 1, 0, 8, 0, 0)
		#print self.wordsDict
		#need h segment fix with horn map
		self.updateSendList()

		self.adjustAllBanks()

	def blankMap(self):
		pass

	def buildAddrMap(self, sport):
		pass

	def adjustAllBanks(self, game=None):
		if self.sport=='MPBASEBALL1' or self.sport=='MMBASEBALL3' or self.sport=='MPLINESCORE5':
			self.wordsDict[1] = self.mp.Encode(1, 1, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[2] = self.mp.Encode(1, 1, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[4] = self.mp.Encode(1, 1, 4, 1, 0, 0, 8, 0, 0)
			#self.wordsDict[5] = self.mp.Encode(1, 2, 1, 0, 1, 8, 8, 0, 0)
			#self.wordsDict[6] = self.mp.Encode(1, 2, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[8] = self.mp.Encode(1, 2, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[12] = self.mp.Encode(1, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[16] = self.mp.Encode(1, 4, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[20] = self.mp.Encode(2, 1, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[21] = self.mp.Encode(2, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[28] = self.mp.Encode(2, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[32] = self.mp.Encode(2, 4, 4, 1, 0, 0, 8, 0, 0)

		elif self.sport=='MPLINESCORE4':
			#self.wordsDict[1] = self.mp.Encode(1, 1, 1, 0, 1, 8, 8, 0, 0)
			#self.wordsDict[2] = self.mp.Encode(1, 1, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[4] = self.mp.Encode(1, 1, 4, 1, 0, 0, 8, 0, 0)
			#self.wordsDict[5] = self.mp.Encode(1, 2, 1, 0, 1, 8, 8, 0, 0)
			#self.wordsDict[6] = self.mp.Encode(1, 2, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[8] = self.mp.Encode(1, 2, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[12] = self.mp.Encode(1, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[16] = self.mp.Encode(1, 4, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[20] = self.mp.Encode(2, 1, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[21] = self.mp.Encode(2, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[24] = self.mp.Encode(2, 2, 4, 1, 0, 8, 8, 0, 0)
			self.wordsDict[28] = self.mp.Encode(2, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[32] = self.mp.Encode(2, 4, 4, 1, 0, 0, 8, 0, 0)


		elif self.sport=='MPMP_15X1' or self.sport=='MPMP_14X1':
			self.wordsDict[1] = self.mp.Encode(1, 1, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[2] = self.mp.Encode(1, 1, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[4] = self.mp.Encode(1, 1, 4, 1, 0, 0, 8, 0, 0)
			#self.wordsDict[5] = self.mp.Encode(1, 2, 1, 0, 1, 8, 8, 0, 0)
			#self.wordsDict[6] = self.mp.Encode(1, 2, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[8] = self.mp.Encode(1, 2, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[12] = self.mp.Encode(1, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[16] = self.mp.Encode(1, 4, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[20] = self.mp.Encode(2, 1, 4, 1, 0, 0, 8, 0, 0)
			#self.wordsDict[21] = self.mp.Encode(2, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[24] = self.mp.Encode(2, 2, 4, 1, 0, 8, 8, 0, 0)
			self.wordsDict[28] = self.mp.Encode(2, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[32] = self.mp.Encode(2, 4, 4, 1, 0, 0, 8, 0, 0)


		elif self.sport=='MPMULTISPORT1-football' or self.sport=='MPLX3450-football' or self.sport=='MPMULTISPORT1-baseball' or self.sport=='MPLX3450-baseball':
			if self.sport=='MPLX3450-football' or self.sport=='MPLX3450-baseball':
				self.wordsDict[1] = self.mp.Encode(1, 1, 1, 0, 1, 8, 8, 0, 0)
				#self.wordsDict[2] = self.mp.Encode(1, 1, 2, 0, 1, 8, 8, 0, 0)
			else:
				#self.wordsDict[1] = self.mp.Encode(1, 1, 1, 0, 1, 8, 8, 0, 0)
				self.wordsDict[2] = self.mp.Encode(1, 1, 2, 0, 1, 8, 8, 0, 0)

			#self.wordsDict[4] = self.mp.Encode(1, 1, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[5] = self.mp.Encode(1, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[6] = self.mp.Encode(1, 2, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[8] = self.mp.Encode(1, 2, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[12] = self.mp.Encode(1, 3, 4, 1, 0, 0, 8, 0, 0)
			#self.wordsDict[16] = self.mp.Encode(1, 4, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[20] = self.mp.Encode(2, 1, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[21] = self.mp.Encode(2, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[28] = self.mp.Encode(2, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[32] = self.mp.Encode(2, 4, 4, 1, 0, 0, 8, 0, 0)

		elif self.sport=='MPFOOTBALL1' or self.sport=='MMFOOTBALL4' or self.sport=='MMBASEBALL4'or self.sport=='MPBASKETBALL1':
			self.wordsDict[1] = self.mp.Encode(1, 1, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[2] = self.mp.Encode(1, 1, 2, 0, 1, 8, 8, 0, 0)
			self.wordsDict[4] = self.mp.Encode(1, 1, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[5] = self.mp.Encode(1, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[6] = self.mp.Encode(1, 2, 2, 0, 1, 8, 8, 0, 0)
			if  not self.sport=='MPBASKETBALL1':
				self.wordsDict[8] = self.mp.Encode(1, 2, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[12] = self.mp.Encode(1, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[16] = self.mp.Encode(1, 4, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[20] = self.mp.Encode(2, 1, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[21] = self.mp.Encode(2, 2, 1, 0, 1, 8, 8, 0, 0)
			self.wordsDict[28] = self.mp.Encode(2, 3, 4, 1, 0, 0, 8, 0, 0)
			self.wordsDict[32] = self.mp.Encode(2, 4, 4, 1, 0, 0, 8, 0, 0)

		self.updateSendList()

class Blanktest_Mapping(Address_Mapping):
	def __init__(self):
		super(Blanktest_Mapping, self).__init__()

		self.updateSendList()

	def buildAddrMap(self, sport):
		pass

	def adjustAllBanks(self, game):
		pass

def main():
	print "ON"
	c=Config()
	sport='MPLINESCORE5'
	c.writeSport(sport)
	game = selectSportInstance(sport)
	#addrMap=Lamptest_Mapping()
	#addrDict=addrMap.__dict__
	#printDict(addrDict)
	#raw_input()
	addrMap=Address_Mapping(game.gameData['sportType'])
	addrMap.adjustAllBanks(game)
	raw_input()
	addrDict=addrMap.__dict__
	printDict(addrDict)

	LHword0 = addrMap.mp.Encode(2, 2, 1, 1, 0, 6, 9, 0, 0)
	LHword1 = addrMap.mp.Encode(2, 2, 2, 0, 0, 5, 8, 0, 0)
	LHword2 = addrMap.mp.Encode(2, 2, 3, 1, 0, 0, 5, 0, 0)
	LHword3 = addrMap.mp.Encode(2, 2, 4, 0, 0, 0, 6, 0, 0)
	#LHword4 = addrMap.mp.Encode(2, 3, 4, 1, 0, 0, 0, 0, 'abcd')
	#LHword5 = addrMap.mp.Encode(2, 3, 1, 0, 0, 0, 1, 0, 0)
	#LHword6 = addrMap.mp.Encode(2, 1, 1, 0, 0, 0, 1, 0, 0)
	sendList=[LHword0, LHword1 , LHword2, LHword3]#, LHword4, LHword5, LHword6]
	game=addrMap.UnMap(game, addressWordList=[21,22,23,24], sendList=sendList)
	raw_input()
	print
	addrDict=addrMap.__dict__
	printDict(addrDict)

if __name__ == '__main__':
	from serial_packet_Class import Serial_Packet
	main()
